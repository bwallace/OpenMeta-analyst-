<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Split the Elements of a Character Vector</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for strsplit {base}"><tr><td>strsplit {base}</td><td align="right">R Documentation</td></tr></table>
<h2>Split the Elements of a Character Vector</h2>


<h3>Description</h3>

<p>
Split the elements of a character vector <code>x</code> into substrings
according to the presence of substring <code>split</code> within them.
</p>


<h3>Usage</h3>

<pre>
strsplit(x, split, extended = TRUE, fixed = FALSE, perl = FALSE)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
character vector, each element of which is to be split.  Other
inputs, including a factor, will give an error.
</td></tr>
<tr valign="top"><td><code>split</code></td>
<td>
character vector (or object which can be coerced to such)
containing <a href="regex.html">regular expression</a>(s) (unless <code>fixed = TRUE</code>)
to use for splitting.  If empty matches occur, in particular if
<code>split</code> has length 0, <code>x</code> is split into single characters.
If <code>split</code> has length greater than 1, it is re-cycled along
<code>x</code>.
</td></tr>
<tr valign="top"><td><code>extended</code></td>
<td>
logical.  If <code>TRUE</code> (the default), extended regular expression
matching is used, and if <code>FALSE</code> basic regular expressions are
used.
</td></tr>
<tr valign="top"><td><code>fixed</code></td>
<td>
logical.  If <code>TRUE</code> match <code>split</code> exactly, otherwise
use regular expressions.  Has priority over <code>perl</code> and
<code>extended</code>.
</td></tr>
<tr valign="top"><td><code>perl</code></td>
<td>
logical.  Should perl-compatible regexps be used?
Has priority over <code>extended</code>.
</td></tr>
</table>

<h3>Details</h3>

<p>
Argument <code>split</code> will be coerced to character, so
you will see uses with <code>split = NULL</code> to mean
<code>split = character(0)</code>, including in the examples below.
</p>
<p>
Note that splitting into single characters can be done <EM>via</EM>
<code>split=character(0)</code> or <code>split=""</code>; the two are
equivalent. The definition of &lsquo;character&rsquo; here depends on the
locale (and perhaps OS): in a single-byte locale it is a byte, and in
a multi-byte locale it is the unit represented by a &lsquo;wide
character&rsquo; (almost always a Unicode point).
</p>
<p>
A missing value of <code>split</code> does not split the corresponding
element(s) of <code>x</code> at all.
</p>
<p>
The algorithm applied to each input string is
<pre>
    repeat {
        if the string is empty
            break.
        if there is a match
            add the string to the left of the match to the output.
            remove the match and all to the left of it.
        else
            add the string to the output.
            break.
    }
</pre>
Note that this means that if there is a match at the beginning of a
(non-empty) string, the first element of the output is <code>""</code>, but
if there is a match at the end of the string, the output is the same
as with the match removed.
</p>


<h3>Value</h3>

<p>
A list of length <code>length(x)</code> the <code>i</code>-th element of which
contains the vector of splits of <code>x[i]</code>.
<br>
If <code>fixed = TRUE</code> or <code>perl = TRUE</code> and if any element of
<code>x</code> or <code>split</code> is declared to be in UTF-8 (see
<code><a href="Encoding.html">Encoding</a></code>, non-ASCII character strings in the result will
be in UTF-8 and have the encoding declared as UTF-8.  Otherwise they
will be in the current locale's encoding, and be declared to have the
encoding of the current locale if either Latin-1 or UTF-8 and  the
corresponding input had a declared encoding.</p>

<h3>Warning</h3>

<p>
The standard regular expression code has been reported to be very slow
when applied to extremely long character strings
(tens of thousands of characters or more): the code used when
<code>perl = TRUE</code> seems much faster and more reliable for such usages.
</p>
<p>
The <code>perl = TRUE</code> option is only implemented for single-byte and
UTF-8 encodings, and will warn if used in a non-UTF-8 multibyte locale.
</p>


<h3>See Also</h3>

<p>
<code><a href="paste.html">paste</a></code> for the reverse,
<code><a href="grep.html">grep</a></code> and <code><a href="grep.html">sub</a></code> for string search and
manipulation; further <code><a href="nchar.html">nchar</a></code>, <code><a href="substr.html">substr</a></code>.
</p>
<p>
&lsquo;<a href="regex.html">regular expression</a>&rsquo; for the details of the pattern
specification.
</p>


<h3>Examples</h3>

<pre>
noquote(strsplit("A text I want to display with spaces", NULL)[[1]])

x &lt;- c(as = "asfef", qu = "qwerty", "yuiop[", "b", "stuff.blah.yech")
# split x on the letter e
strsplit(x,"e")

unlist(strsplit("a.b.c", "."))
## [1] "" "" "" "" ""
## Note that 'split' is a regexp!
## If you really want to split on '.', use
unlist(strsplit("a.b.c", "\\."))
## [1] "a" "b" "c"
## or
unlist(strsplit("a.b.c", ".", fixed = TRUE))

## a useful function: rev() for strings
strReverse &lt;- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse="")
strReverse(c("abc", "Statistics"))

## get the first names of the members of R-core
a &lt;- readLines(file.path(R.home("doc"),"AUTHORS"))[-(1:8)]
a &lt;- a[(0:2)-length(a)]
(a &lt;- sub(" .*","", a))
# and reverse them
strReverse(a)

## Note that final empty strings are not produced:
strsplit(paste(c("", "a", ""), collapse="#"), split="#")[[1]]
# [1] ""  "a"
## and also an empty string is only produced before a definite match:
strsplit("", " ")[[1]]    # character(0)
strsplit(" ", " ")[[1]]   # [1] ""
</pre>



<hr><div align="center">[Package <em>base</em> version 2.9.2 <a href="00Index.html">Index</a>]</div>

</body></html>
