<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Common Bivariate Trellis Plots</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for xyplot {lattice}"><tr><td>xyplot {lattice}</td><td align="right">R Documentation</td></tr></table>
<h2>Common Bivariate Trellis Plots</h2>


<h3>Description</h3>

<p>
These are the most commonly used high level Trellis functions to plot
pairs of variables. By far the most common is <code>xyplot</code>, designed
mainly for two continuous variates (though factors can be supplied as
well, in which case they will simply be coerced to numeric), which
produces Conditional Scatter plots. The others are useful when one of
the variates is a factor or a shingle.  Most of these arguments are
also applicable to other high level functions in the lattice package,
but are only documented here.
</p>


<h3>Usage</h3>

<pre>
xyplot(x, data, ...)
dotplot(x, data, ...)
barchart(x, data, ...)
stripplot(x, data, ...)
bwplot(x, data, ...)

## S3 method for class 'formula':
xyplot(x,
       data,
       allow.multiple = is.null(groups) || outer,
       outer = !is.null(groups),
       auto.key = FALSE,
       aspect = "fill",
       panel = lattice.getOption("panel.xyplot"),
       prepanel = NULL,
       scales = list(),
       strip = TRUE,
       groups = NULL,
       xlab,
       xlim,
       ylab,
       ylim,
       drop.unused.levels = lattice.getOption("drop.unused.levels"),
       ...,
       lattice.options = NULL,
       default.scales,
       subscripts = !is.null(groups),
       subset = TRUE)

## S3 method for class 'formula':
dotplot(x,
        data,
        panel = lattice.getOption("panel.dotplot"),
        ...)

## S3 method for class 'formula':
barchart(x,
         data,
         panel = lattice.getOption("panel.barchart"),
         box.ratio = 2,
         ...)

## S3 method for class 'formula':
stripplot(x,
          data,
          panel = lattice.getOption("panel.stripplot"),
          ...)

## S3 method for class 'formula':
bwplot(x,
       data,
       allow.multiple = is.null(groups) || outer,
       outer = FALSE,
       auto.key = FALSE,
       aspect = "fill",
       panel = lattice.getOption("panel.bwplot"),
       prepanel = NULL,
       scales = list(),
       strip = TRUE,
       groups = NULL,
       xlab,
       xlim,
       ylab,
       ylim,
       box.ratio = 1,
       horizontal = NULL,
       drop.unused.levels = lattice.getOption("drop.unused.levels"),
       ...,
       lattice.options = NULL,
       default.scales,
       subscripts = !is.null(groups),
       subset = TRUE)

</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x</code></td>
<td>
The object on which method dispatch is carried out.
<br>
For the <code>"formula"</code> methods, a formula describing the form of
conditioning plot. The formula is generally of the form <code>y ~ x
      | g1 * g2 * ...</code>, indicating that plots of <code>y</code> (on the y
axis) versus <code>x</code> (on the x axis) should be produced conditional
on the variables <code>g1, g2, ...</code>. However, the conditioning
variables <code>g1,g2,...</code> may be omitted. The formula can also be
supplied as <code>y ~ x | g1 + g2 + ...</code>.
<br>
For all of these functions, with the exception of <code>xyplot</code>, a
formula of the form <code> ~ x | g1 * g2 * ...</code> is also
allowed. In that case, <code>y</code> defaults to <code>names(x)</code> if
<code>x</code> is named, and a factor with a single level otherwise.
<br>
Other usage of the form <code>dotplot(x)</code> is handled by method
dispatch as appropriate.  The <code>numeric</code> method is equivalent to
a call with no left hand side and no conditioning variables in the
formula.  For <code>barchart</code> and <code>dotplot</code>, non-trivial
methods exist for tables and arrays, documented under
<code><a href="barchart.table.html">barchart.table</a></code>.
<br>
The conditioning variables <code>g1, g2, ...</code> must be either
factors or shingles.  Shingles are a way of processing numeric
variables for use in conditioning. See documentation of
<code><a href="shingles.html">shingle</a></code> for details. Like factors, they have a
<code>"levels"</code> attribute, which is used in producing the
conditional plots.
<br>
Numeric conditioning variables are converted to shingles by the
function <code>shingle</code> (however, using <code><a href="shingles.html">equal.count</a></code>
might be more appropriate in many cases) and character vectors are
coerced to factors.
<br>
The formula can involve expressions, e.g. <code>sqrt()</code>,
<code>log()</code>.
<br>
A special case is when the left and/or right sides of the formula
(before the conditioning variables) contain a &lsquo;+&rsquo; sign, e.g.,
<code>y1+y2 ~ x | a*b</code>. This formula would be taken to mean that the
user wants to plot both <code>y1~x | a*b</code> and <code>y2~x | a*b</code>, but
with the <code>y1~x</code> and <code>y2~x</code> superposed in each panel (this
is slightly more complicated in <code>barchart</code>). The two parts
would be distinguished by different graphical parameters. This is
essentially what the <code>groups</code> argument would produce, if
<code>y1</code> and <code>y2</code> were concatenated to produce a longer
vector, with the <code>groups</code> argument being an indicator of which
rows come from which variable.  In fact, this is exactly what is
done internally using the <code><a href="../../stats/html/reshape.html">reshape</a></code> function. This
feature cannot be used in conjunction with the <code>groups</code>
argument.  
<br>
To interpret <code>y1 + y2</code> as a sum, one can either set
<code>allow.multiple=FALSE</code> or use <code>I(y1+y2)</code>.
<br>
A variation on this feature is when the <code>outer</code> argument is set
to <code>TRUE</code> as well as <code>allow.multiple</code>. In that case, the
plots are not superposed in each panel, but instead separated into
different panels (as if a new conditioning variable had been added).
<br>
The <code>x</code> and <code>y</code> variables should both be numeric in
<code>xyplot</code>, and an attempt is made to coerce them if
not. However, if either is a factor, the levels of that factor are
used as axis labels. In the other four functions documented here,
exactly one of <code>x</code> and <code>y</code> should be numeric, and the
other a factor or shingle. Which of these will happen is determined
by the <code>horizontal</code> argument &mdash; if <code>horizontal=TRUE</code>,
then <code>y</code> will be coerced to be a factor or shingle, otherwise
<code>x</code>. The default value of <code>horizontal</code> is <code>FALSE</code> if
<code>x</code> is a factor or shingle, <code>TRUE</code> otherwise. (The
functionality provided by <code>horizontal=FALSE</code> is not
S-compatible.)
<br>
Note that this argument used to be called <code>formula</code> in earlier
versions (when the high level functions were not generic and the
formula method was essentially the only method).  This is no longer
allowed.  It is recommended that this argument not be named in any
case, but rather be the first (unnamed) argument.
<br>
</td></tr>
<tr valign="top"><td><code>data</code></td>
<td>
For the <code>formula</code> method, a data frame containing values (or
more precisely, anything that is a valid <code>envir</code> argument in
<code><a href="../../base/html/eval.html">eval</a></code>, e.g. a list or an environment) for any variables in
the formula, as well as <code>groups</code> and <code>subset</code> if
applicable.  If not found in <code>data</code>, or if <code>data</code> is
unspecified, the variables are looked for in the environment of the
formula.  For other methods (where <code>x</code> is not a formula),
<code>data</code> is usually ignored, often with a warning.
</td></tr>
<tr valign="top"><td><code>allow.multiple, outer</code></td>
<td>
logical flags to control what happens with formulas like <code>y1 +
      y2 ~ x</code>. See the entry for <code>x</code> for details.
<code>allow.multiple</code> defaults to <code>TRUE</code> whenever it makes
sense, and <code>outer</code> defaults to <code>FALSE</code> except when
<code>groups</code> is explicitly specified or grouping doesn't make sense
for the default panel function
</td></tr>
<tr valign="top"><td><code>box.ratio</code></td>
<td>
applicable to <code>bwplot</code>, <code>barchart</code> and
<code>stripplot</code>, specifies the ratio of the width of the rectangles
to the inter rectangle space.
</td></tr>
<tr valign="top"><td><code>horizontal</code></td>
<td>
logical, applicable to <code>bwplot, dotplot,
      barchart</code> and <code>stripplot</code>. Determines which of <code>x</code> and
<code>y</code> is to be a factor or shingle (<code>y</code> if TRUE, <code>x</code>
otherwise). Defaults to <code>FALSE</code> if <code>x</code> is a factor or
shingle, <code>TRUE</code> otherwise. This argument is used to process the  
arguments to these high level functions, but more importantly, it is
passed as an argument to the panel function, which is supposed to
use it as appropriate.
<br>
A potentially useful component of <code>scales</code> in this case might
be <code>abbreviate = TRUE</code>, in which case long labels which would
usually overlap will be abbreviated. <code>scales</code> could also
contain a <code>minlength</code> argument in this case, which would be
passed to the <code>abbreviate</code> function.
</td></tr>
<tr valign="top"><td><code>panel</code></td>
<td>
Once the subset of rows defined by each unique combination of the
levels of the grouping variables are obtained (see details), the
corresponding <code>x</code> and <code>y</code> variables (or other variables,
as appropriate, in the case of other high level functions) are
passed on to be plotted in each panel. The actual plotting is done
by the function specified by the <code>panel</code> argument.  Each high
level function has its own default panel function, which could
depend on whether the <code>groups</code> argument was supplied.
<br>
The panel function can be a function object or a character string
giving the name of a predefined function.
<br>
Much of the power of Trellis Graphics comes from the ability to
define customized panel functions.  A panel function appropriate
for the functions described here would usually expect arguments
named <code>x</code> and <code>y</code>, which would be provided by the
conditioning process.  It can also have other arguments. It might be
useful to know in this context that all arguments passed to a high
level Trellis function (such as <code>xyplot</code>) that are not
recognized by it are passed through to the panel function. It is
thus generally good practice when defining panel functions to allow
a <code>...</code> argument. Such extra arguments typically control
graphical parameters, but other uses are also common. See
documentation for individual panel functions for specifics.
<br>
Note that unlike in S-PLUS, it is not guaranteed that panel
functions will be supplied only numeric vectors for the <code>x</code> and
<code>y</code> arguments; they can be factors as well (but not
shingles).  Panel functions need to handle this case, which in most
cases can be done by simply coercing them to numeric.
<br>
Technically speaking, panel functions must be written using Grid
graphics functions.  However, knowledge of Grid is usually not
necessary to construct new custom panel functions, there are several
predefined panel functions which can help; for example,
<code>panel.grid</code>, <code>panel.loess</code>, etc.  There are also some
grid-compatible replacements of commonly used base R graphics
functions useful for this purpose.  For example, <code>lines</code> can be
replaced by <code>llines</code> (or equivalently, <code>panel.lines</code>).
Note that base R graphics functions like <code>lines</code> will not work
in a lattice panel function.
<br>
One case where a bit more is required of the panel function is when
the <code>groups</code> argument is not null. In that case, the panel
function should also accept arguments named <code>groups</code> and
<code>subscripts</code> (see below for details).  A useful panel function
predefined for use in such cases is <code>panel.superpose</code>, which
can be combined with different <code>panel.groups</code> functions
determining what is plotted for each group.  See the examples
section for an interaction plot constructed in this way.  Several
other panel functions can also handle the <code>groups</code> argument,
including the default ones for <code>barchart</code>, <code>dotplot</code> and
<code>stripplot</code>.
<br>
Even when <code>groups</code> is not present, the panel function can have
<code>subscripts</code> as a formal argument.  In either case, the
<code>subscripts</code> argument passed to the panel function are the
indices of the <code>x</code> and <code>y</code> data for that panel in the
original <code>data</code>, BEFORE taking into account the effect of
the <code>subset</code> argument.  Note that <code>groups</code> remains
unaffected by any subsetting operations, so
<code>groups[subscripts]</code> gives the values of <code>groups</code> that
correspond to the data in that panel.
<br>
This interpretation of <code>subscripts</code> does not hold when the
extended formula interface is in use (i.e., when
<code>allow.multiple</code> is in effect).  A comprehensive description
would be too complicated (details can be found in the source code of
the function <code>latticeParseFormula</code>), but in short, the extended
interface works by creating an artificial grouping variable that is
longer than the original data frame, and consequently,
<code>subscripts</code> needs to refer to rows beyond those in the
original data.  To further complicate matters, the artificial
grouping variable is created after any effect of <code>subset</code>, in
which case <code>subscripts</code> has practically no relationship with
corresponding rows in the original data frame.
<br>
One can also use functions called <code><a href="panel.number.html">panel.number</a></code> and
<code><a href="panel.number.html">packet.number</a></code>, representing panel order and packet
order respectively, inside the panel function (as well as the strip
function or while interacting with a lattice display using
<code><a href="interaction.html">trellis.focus</a></code> etc).  Both provide a simple integer
index indicating which panel is currently being drawn, but differ in
how the count is calculated.  The panel number is a simple
incremental counter that starts with 1 and is incremented each time
a panel is drawn.  The packet number on the other hand indexes the
combination of levels of the conditioning variables that is
represented by that panel.  The two indices coincide unless the
order of conditioning variables is permuted and/or the plotting
order of levels within one or more conditioning variables is altered
(using <code>perm.cond</code> and <code>index.cond</code> respectively), in
which case <code>packet.number</code> gives the index corresponding to the
&lsquo;natural&rsquo; ordering of that combination of levels of the
conditioning variables.
<br>
<code><a href="panel.xyplot.html">panel.xyplot</a></code> has an argument called <code>type</code> which
is worth mentioning here because it is quite frequently used (and as
mentioned above, can be passed to <code>xyplot</code> directly).  In the
event that a <code>groups</code> variable is used,
<code><a href="panel.xyplot.html">panel.xyplot</a></code> calls <code><a href="panel.superpose.html">panel.superpose</a></code>,
arguments of which can also be passed directly to <code>xyplot</code>.
Panel functions for <code>bwplot</code> and friends should have an
argument called <code>horizontal</code> to account for the cases when
<code>x</code> is the factor or shingle.
</td></tr>
<tr valign="top"><td><code>aspect</code></td>
<td>
controls physical aspect ratio of the panels (same for
all the panels). It can be specified as a ratio (vertical
size/horizontal size) or as a character string. Legitimate 
values are <code>"fill"</code> (the default) which tries to make the
panels as big as possible to fill the available space; <code>"xy"</code>,
which <B>tries</B> to compute the aspect based on the 45 degree
banking rule (see <EM>Visualizing Data</EM> by William S. Cleveland
for details); and <code>"iso"</code> for isometric scales, where the
relation between physical distance on the device and distance in the
data scale are forced to be the same for both axes.
<br>
If a <code>prepanel</code> function is specified and it returns components
<code>dx</code> and <code>dy</code>, these are used for banking calculations.
Otherwise, values from the default prepanel function are used.
Currently, only the default prepanel function for <code>xyplot</code> can
be expected to produce sensible banking calculations.  See
<code><a href="banking.html">banking</a></code> for details on the implementation of banking .
</td></tr>
<tr valign="top"><td><code>groups</code></td>
<td>
a variable or expression to be evaluated in the data
frame specified by <code>data</code>, expected to act as a grouping
variable within each panel, typically used to distinguish different
groups by varying graphical parameters like color and line type.
Formally, if <code>groups</code> is specified, then <code>groups</code> along
with <code>subscripts</code> is passed to the panel function, which is
expected to handle these arguments.  Not all pre-defined panel
functions know how to, but for high level functions where grouping
is appropriate, the default panel functions are chosen so that they
do.
<br>
It is very common to use a key (legend) when a grouping
variable is specified.  See entries for <code>key</code>, <code>auto.key</code>
and <code><a href="simpleKey.html">simpleKey</a></code> for how to draw a key.
</td></tr>
<tr valign="top"><td><code>auto.key</code></td>
<td>
A logical (indicating whether a key is to be drawn automatically when
a grouping variable is present in the plot), or a list of parameters
that would be valid arguments to <code><a href="simpleKey.html">simpleKey</a></code> (in effect,
most valid components of <code>key</code> can be specified in this
manner).  If <code>auto.key</code> is not <code>FALSE</code>, <code>groups</code> is
non-null and there is no <code>key</code> or <code>legend</code> argument
specified in the call, a key is created with <code>simpleKey</code> with
<code>levels(groups)</code> as the first argument. (Note: this may not
work in all high level functions, but it does work for the ones
where grouping makes sense with the default panel function)
<br>
<code>simpleKey</code> uses the trellis settings to determine the
graphical parameters in the key, so this will be meaningful only if
the settings are used in the plot as well.
<br>
One disadvantage to using <code>key</code> (or even <code>simpleKey</code>)
directly is that the graphical parameters used in the key are
absolutely determined at the time when the <code>"trellis"</code> object is
created. Consequently, if a plot once created is re-<code>print</code>ed
with different settings, the parameter settings for the original
device will be used. However, with <code>auto.key</code>, the key is
actually created at printing time, so the key settings will match
the device settings.
</td></tr>
<tr valign="top"><td><code>prepanel</code></td>
<td>
function that takes the same arguments as the <code>panel</code> function
and returns a list, possibly containing components named
<code>xlim</code>, <code>ylim</code>, <code>dx</code> and <code>dy</code> (and less
frequently, <code>xat</code> and <code>yat</code>).
<br>
The <code>xlim</code> and <code>ylim</code> components are similar to the high
level <code>xlim</code> and <code>ylim</code> arguments (i.e., they are usually
a numeric vector of length 2 defining a range of values, or a
character vector representing levels of a factor).  If the
<code>xlim</code> and <code>ylim</code> arguments are not explicitly specified
(possibly as components in <code>scales</code>), then the actual limits of
the panels are guaranteed to include the limits returned by the
prepanel function. This happens globally if the <code>relation</code>
component of <code>scales</code> is <code>"same"</code>, and on a panel by panel
basis otherwise. See <code>xlim</code> to see what forms of the components
<code>xlim</code> and <code>ylim</code> are allowed.
<br>
The <code>dx</code> and <code>dy</code> components are used for banking
computations in case <code>aspect</code> is specified as <code>"xy"</code>.  See
documentation for the function <code>banking</code> for details regarding
how this is done.
<br>
The return value of the prepanel function need not have all the
components named above; in case some are missing, they are replaced
by the usual component-wise defaults.
<br>
If <code>xlim</code> or <code>ylim</code> is a character vector (which is
appropriate when the corresponding variable is a factor), this
implicitly indicates that the scale should include the first
<code>n</code> integers, where <code>n</code> is the length of <code>xlim</code> or
<code>ylim</code>, as the case may be.  The elements of the character
vector are used as the default labels for these <code>n</code> integers.
Thus, to make this information consistent between panels, the
<code>xlim</code> or <code>ylim</code> values should represent all the levels of
the corresponding factor, even if some are not used within that
particular panel.
<br>
In such cases, an additional component <code>xat</code> or <code>yat</code> may
be returned by the <code>prepanel</code> function, which should be a
subset of <code>1:n</code>, indicating which of the <code>n</code> values
(levels) are actually represented in the panel.  This is useful when
calculating the limits with <code>relation="free"</code> or
<code>relation="sliced"</code> in <code>scales</code>.
<br>
The prepanel function is responsible for providing a meaningful
return value when the <code>x</code>, <code>y</code> (etc.) variables are
zero-length vectors.  When nothing is appropriate, values of NA
should be returned for the <code>xlim</code> and <code>ylim</code> components.
</td></tr>
<tr valign="top"><td><code>strip</code></td>
<td>
logical flag or function.  If <code>FALSE</code>, strips are not drawn.
Otherwise, strips are drawn using the <code>strip</code> function, which
defaults to <code>strip.default</code>.  See documentation of
<code>strip.default</code> to see the arguments that are available to the
strip function.  This description also applies to the
<code>strip.left</code> argument (see <code>...</code> below), which can be
used to draw strips on the left of each panel, which can be useful
for wide short panels, e.g. in time series plots.
</td></tr>
<tr valign="top"><td><code>xlab</code></td>
<td>
character string or expression (or a <code>"grob"</code>) giving
label for the x-axis.  Defaults to the expression for <code>x</code> in
<code>formula</code>.  Can be specified as <code>NULL</code> to omit the label
altogether.  Finer control is possible, as described in the entry
for <code>main</code>, with the additional feature that if the
<code>label</code> component is omitted from the list, it is replaced by
the default <code>xlab</code>.
</td></tr>
<tr valign="top"><td><code>ylab</code></td>
<td>
character string or expression (or <code>"grob"</code>) giving
label for the y-axis.  Defaults to the expression for <code>y</code> in
<code>formula</code>.  Fine control is possible, see entries for
<code>main</code> and <code>xlab</code>.
</td></tr>
<tr valign="top"><td><code>scales</code></td>
<td>
list determining how the x- and y-axes (tick marks and
labels) are drawn.  The list contains parameters in
<code>name=value</code> form, and may also contain two other lists called
<code>x</code> and <code>y</code> of the same form (described below).
Components of <code>x</code> and <code>y</code> affect the respective axes only,
while those in <code>scales</code> affect both.  When parameters are
specified in both lists, the values in <code>x</code> or <code>y</code> are
used.  Note that certain high-level functions have defaults that are
specific to a particular axis (e.g., <code>bwplot</code> has
<code>alternating=FALSE</code> for the y-axis only); these can be
overridden only by an entry in the corresponding component of
<code>scales</code>.
<br>
The possible components are :
<br>
<dl>
<dt><code>relation</code></dt><dd>character string that determines how axis limits are calculated
for each panel.  Possible values are <code>"same"</code> (default),
<code>"free"</code> and <code>"sliced"</code>.  For <code>relation="same"</code>,
the same limits, usually large enough to encompass all the data,
are used for all the panels.  For <code>relation="free"</code>, limits
for each panel is determined by just the points in that panel.
Behavior for <code>relation="sliced"</code> is similar, except that
the length (max - min) of the scales are constrained to remain
the same across panels.
<br>
The determination of what axis limits are suitable for each
panel can be controlled by the <code>prepanel</code> function, which
can be overridden by <code>xlim</code>, <code>ylim</code> or
<code>scales$limits</code>.  If relation is not <code>"same"</code>, the
value of <code>xlim</code> etc is normally ignored, except when it is
a list, in which case it is treated as if its components were
the limit values obtained from the prepanel calculations for
each panel.
</dd>
<dt><code>tick.number</code></dt><dd>Suggested number of ticks (ignored for a factor, shingle or
character vector, in which case there is no natural rule for
leaving out some of the labels. But see <code>xlim</code>).
</dd>
<dt><code>draw</code></dt><dd>logical, defaults to <code>TRUE</code>, whether to draw the axis at
all.
</dd>
<dt><code>alternating</code></dt><dd>logical specifying whether axis labels should alternate from one
side of the group of panels to the other.  For finer control,
alternating can be a vector (replicated to be as long as the
number of rows or columns per page) consisting of the following
numbers
<ul>
<li>0: do not draw tick labels
<li>1: bottom/left
<li>2: top/right
<li>3: both.
</ul>
<code>alternating</code> applies only when <code>relation="same"</code>.
The default is <code>TRUE</code>, or equivalently, <code>c(1, 2)</code>
</dd>
<dt><code>limits</code></dt><dd>same as xlim and ylim.
</dd>
<dt><code>at</code></dt><dd>location of tick marks along the axis (in native
coordinates), or a list as long as the number of panels
describing tick locations for each panel.
</dd>
<dt><code>labels</code></dt><dd>Labels (strings or expressions) to go along with <code>at</code>. Can
be a list like <code>at</code> as well.
</dd>
<dt><code>cex</code></dt><dd>numeric multiplier to control character sizes for axis labels.
Can be a vector of length 2, to control left/bottom and
right/top separately.
</dd>
<dt><code>font</code>, <code>fontface</code>, <code>fontfamily</code></dt><dd>specifies font for axis labels.
</dd>
<dt><code>tck</code></dt><dd>numeric to control length of tick marks. Can be a vector of
length 2, to control left/bottom and right/top separately.
</dd>
<dt><code>col</code></dt><dd>color of ticks and labels.
</dd>
<dt><code>rot</code></dt><dd>Angle by which the axis labels are to be rotated. Can be a
vector of length 2, to control left/bottom and right/top
separately.
</dd>
<dt><code>abbreviate</code></dt><dd>logical, whether to abbreviate the labels using
<code>abbreviate</code>.  Can be useful for long labels (e.g., in
factors), especially on the x-axis.
</dd>
<dt><code>minlength</code></dt><dd>argument passed to <code>abbreviate</code> if <code>abbreviate=TRUE</code>.
</dd>
<dt><code>log</code></dt><dd>Controls whether the corresponding variable (<code>x</code> or
<code>y</code>) will be log transformed before being passed to the
panel function.  Defaults to <code>FALSE</code>, in
which case the data are not transformed.  Other possible values
are any number that works as a base for taking logarithm,
<code>TRUE</code> (which is equivalent to 10), and <code>"e"</code> (for the
natural logarithm).  As a side effect, the corresponding axis is
labeled differently.  Note that this is a transformation of the
data, not the axes.  Other than the axis labeling, using this
feature is no different than transforming the data in the
formula; e.g., <code>scales=list(x = list(log = 2))</code> is
equivalent to <code>y ~ log2(x)</code>.  
<br>
</dd>
<dt><code>format</code></dt><dd>the <code>format</code> to use for POSIXct variables. See
<code><a href="../../base/html/strptime.html">strptime</a></code> for description of valid values.
</dd>
<dt><code>axs</code></dt><dd>character, <code>"r"</code> or <code>"i"</code>.  In the latter case, the
axis limits are calculated as the exact data range, instead of
being padded on either side. (May not always work as expected.)
</dd>
</dl>
<br>
Note that much of the function of <code>scales</code> is accomplished by
<code>pscales</code> in <code>splom</code>.
</td></tr>
<tr valign="top"><td><code>subscripts</code></td>
<td>
logical specifying whether or not a vector named <code>subscripts</code>
should be passed to the panel function.  Defaults to <code>FALSE</code>,
unless <code>groups</code> is specified, or if the panel function accepts
an argument named <code>subscripts</code>. (One should be careful when
defining the panel function on-the-fly.)
</td></tr>
<tr valign="top"><td><code>subset</code></td>
<td>
logical or integer indexing vector (can be specified in terms of
variables in <code>data</code>).  Only these rows of <code>data</code> will be
used for the plot.  If <code>subscripts</code> is <code>TRUE</code>, the
subscripts will provide indices to the rows of data before the
subsetting is done.  Whether levels of factors in the data frame
that are unused after the subsetting will be dropped depends on the
<code>drop.unused.levels</code> argument.
</td></tr>
<tr valign="top"><td><code>xlim</code></td>
<td>
Normally a numeric vector of length 2 (possibly a
DateTime object) giving minimum and maximum for the x-axis, or, a
character vector, expected to denote the levels of <code>x</code>.  The
latter form is interpreted as a range containing c(1, length(xlim)),
with the character vector determining labels at tick positions
<code>1:length(xlim)</code>
<br>
<code>xlim</code> could also be a list, with as many components as the
number of panels (recycled if necessary), with each component as
described above.  This is meaningful only when
<code>scales$x$relation</code> is <code>"free"</code> or <code>"sliced"</code>, in
which case these are treated as if they were the corresponding limit
components returned by prepanel calculations.
<br>
</td></tr>
<tr valign="top"><td><code>ylim</code></td>
<td>
similar to <code>xlim</code>, applied to the y-axis. </td></tr>
<tr valign="top"><td><code>drop.unused.levels</code></td>
<td>
logical indicating whether the unused levels of factors will be
dropped, usually relevant with a subsetting operation is performed
or an <code><a href="../../base/html/interaction.html">interaction</a></code> is created.  Unused levels are
usually dropped, but it is sometimes appropriate to suppress
dropping to preserve a useful layout.  For finer control, this
argument could also be list containing components <code>cond</code> and
<code>data</code>, both logical, indicating desired behavior for
conditioning variables and data variables respectively.  The default
is given by <code>lattice.getOption("drop.unused.levels")</code>, which
is initially set to <code>TRUE</code> for both components.  Note that this
argument does not control dropping of levels of the <code>groups</code>
argument.
</td></tr>
<tr valign="top"><td><code> default.scales </code></td>
<td>
list giving the default values of <code>scales</code> for a particular
high level function.  This should not be of any interest to the
normal user, but may be helpful when defining other functions that
act as a wrapper to one of the high level lattice functions.
</td></tr>
<tr valign="top"><td><code>lattice.options</code></td>
<td>
a list that could be supplied to <code><a href="lattice.options.html">lattice.options</a></code>.
These options are temporarily in effect for the duration of the
call, after which the settings revert back to whatever they were
before.  The settings are also retained along with the object and
reused during plotting.  This enables the user to attach options
settings to the trellis object itself rather than change the
settings globally.  See also the  <code>par.settings</code> argument
described below for a similar treatment of graphical settings.
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
further arguments, usually not directly processed by the
high level functions documented here, but rather passed on to other
functions. Such arguments can be broadly categorized into two types:
those that affect all high level Trellis functions in a similar
manner, and those that are meant for the specific panel function
used, which may differ across high level functions.
<br>
The first group of arguments are processed by a common, unexported
function called <code>trellis.skeleton</code>.  These arguments affect all
high level functions, but are only documented here, except to
override the behaviour described here.  All other arguments
specified in a high level call, specifically those neither described
here nor in the help page of the relevant high level function, are
passed unchanged to the panel function used.  By convention, the
default panel function used for any high level function is named as
<code>"panel."</code> followed by the name of the high level function; 
for example, the default panel function for <code>bwplot</code> is
<code>panel.bwplot</code>.  In practical terms, this means that in
addition to the help page of the high level function being used, the
user should also consult the help page of the corresponding panel
function for arguments that may be specified in the high level call.
<br>
The effect of the first group of common arguments are as follows:
<br>
<dl>
<dt><code>as.table</code>:</dt><dd>logical that controls the order in which panels
should be plotted: if <code>FALSE</code> (the default), panels are drawn
left to right, bottom to top (as in a graph); if <code>TRUE</code>, left
to right, top to bottom.
</dd>
<br>
<dt><code>between</code>:</dt><dd>a list with components <code>x</code> and <code>y</code> (both
usually 0 by default), numeric vectors specifying the space between
the panels (units are character heights). <code>x</code> and <code>y</code> are
repeated to account for all panels in a page and any extra
components are ignored. The result is used for all pages in a
multi page display. (In other words, it is not possible to use
different <code>between</code> values for different pages).
</dd>
<br>
<dt><code>key</code>:</dt><dd>A list of arguments that define a legend to be drawn on the plot.
This list is used as an argument to the <code><a href="draw.key.html">draw.key</a></code>
function, which produces a grid object eventually plotted by the
print method for <code>"trellis"</code> objects.
<br>
There is also a less flexible but usually sufficient shortcut
function <code><a href="simpleKey.html">simpleKey</a></code> that can generate such a list, as
well as the argument <code>auto.key</code> that can be convenient in the
most common situation where legends are used, namely when there is a
grouping variable. To use more than one legend, or to have arbitrary
legends not constrained by the structure imposed by <code>key</code>, use
the <code>legend</code> argument.
<br>
The position of the key can be controlled in either of two
possible ways. If a component called <code>space</code> is present,
the key is positioned outside the plot region, in one of the
four sides, determined by the value of <code>space</code>, which can
be one of <code>"top"</code>, <code>"bottom"</code>, <code>"left"</code> and
<code>"right"</code>.  Alternatively, the key can be positioned inside
the plot region by specifying components <code>x</code>, <code>y</code> and
<code>corner</code>. <code>x</code> and <code>y</code> determine the location of
the corner of the key given by <code>corner</code>, which is usually
one of <code>c(0,0)</code>, <code>c(1,0)</code>, <code>c(1,1)</code> and
<code>c(0,1)</code>, which denote the corners of the unit square.
Fractional values are also allowed, in which case <code>x</code> and
<code>y</code> determine the position of an arbitrary point inside (or
outside for values outside the unit interval) the key.
<br>
<code>x</code> and <code>y</code> should be numbers between 0 and 1, giving
coordinates with respect to the &ldquo;display area&rdquo;.
Depending on the value of
<code>lattice.getOption("legend.bbox")</code>, this can be either the
full figure region (<code>"full"</code>), or just the region that
bounds the panels and strips (<code>"panel"</code>).
<br>
The key essentially consists of a number of columns, possibly
divided into blocks, each containing some rows.  The contents of the
key are determined by (possibly repeated) components named
<code>"rectangles"</code>, <code>"lines"</code>, <code>"points"</code> or
<code>"text"</code>.  Each of these must be lists with relevant graphical
parameters (see later) controlling their appearance.  The <code>key</code>
list itself can contain graphical parameters, these would be used if
relevant graphical components are omitted from the other components.
<br>
The length (number of rows) of each such column (except <code>"text"</code>s)
is taken to be the largest of the lengths of the graphical
components, including the ones specified outside (see the entry for
<code>rep</code> below for details on this). The <code>"text"</code> component has to
have a character or expression vector as its first component, and
the length of this vector determines the number of rows.
<br>
The graphical components that can be included in <code>key</code> (and
also in the components named <code>"text"</code>, <code>"lines"</code>,
<code>"points"</code> and <code>"rectangles"</code> as appropriate) are:
<br>
<ul>
<li><code>cex=1</code>
<li><code>col="black"</code>
<li><code>alpha=1</code>
<li><code>lty=1</code>
<li><code>lwd=1</code>
<li><code>font=1</code>
<li><code>fontface</code>
<li><code>fontfamily</code>
<li><code>pch=8</code>
<li><code>adj=0</code>
<li><code>type="l"</code>
<li><code>size=5</code>
<li><code>angle=0</code>
<li><code>density=-1</code>
</ul>
<br>
In addition, the component <code>border</code> can be included inside
the <code>"rect"</code> component to control the border color of the
rectangles; when specified at the top level, <code>border</code>
controls the border of the entire key (see below).
<br>
<code>angle</code> and <code>density</code> are unimplemented.  <code>size</code>
determines the width of columns of rectangles and lines in
character widths. <code>type</code> is relevant for lines; <code>"l"</code>
denotes a line, <code>"p"</code> denotes a point, and <code>"b"</code> and
<code>"o"</code> both denote both together.
<br>
Other possible components of <code>key</code> are:
<br>
<dl>
<dt><code>reverse.rows</code></dt><dd>logical, defaulting to <code>FALSE</code>.  If <code>TRUE</code>, all
components are reversed <EM>after</EM> being replicated
(the details of which may depend on the value of
<code>rep</code>).  This is useful in certain situations,
e.g. with a grouped <code>barchart</code> with <code>stack =
              FALSE</code> with the categorical variable on the vertical axis,
where the bars in the plot will usually be ordered from
bottom to top, but the corresponding legend will have the
levels from top to bottom (unless, of course,
<code>reverse.rows = TRUE</code>).  Note that in this case, unless
all columns have the same number or rows, they will no
longer be aligned.
</dd>
<dt><code>between</code></dt><dd>numeric vector giving the amount of space (character widths)
surrounding each column (split equally on both sides)
</dd>
<dt><code>title</code></dt><dd>string or expression giving a title for the key
</dd>
<dt><code>rep</code></dt><dd>logical, defaults to <code>TRUE</code>.  By default, it's assumed that
all columns in the key (except the <code>"text"</code>s) will have the same
number of rows, and all components are replicated to be as long
as the longest. This can be suppressed by specifying
<code>rep=FALSE</code>, in which case the length of each column will
be determined by components of that column alone.
</dd>
<dt><code>cex.title</code></dt><dd>cex for the title
</dd>
<dt><code>lines.title</code></dt><dd>how many lines the title should occupy (in multiples of
itself).  Defaults to 2.
</dd>
<dt><code>padding.text</code></dt><dd>how much space (padding) should be used above and below each
row containing text, in multiples of the default, which is
currently <code>0.2 * "lines"</code>.  This padding is in addition to
the normal height of any row that contains text, which is the
minimum amount necessary to contain all the text entries.
</dd>
<dt><code>background</code></dt><dd>background color, defaults to default background
</dd>
<dt><code>alpha.background</code></dt><dd>An alpha transparency value between 0 and 1
</dd>
<dt><code>border</code></dt><dd>either a color for the border, or a logical.  In the latter
case, the border color is black if <code>border</code> is
<code>TRUE</code>, and no border is drawn if it is <code>FALSE</code> (the
default)
</dd>
<dt><code>transparent=FALSE</code></dt><dd>logical, whether key area should have a transparent background
</dd>
<dt><code>columns</code></dt><dd>the number of columns column-blocks the key is to be divided
into, which are drawn side by side.
</dd>
<dt><code>between.columns</code></dt><dd>Space between column blocks, in addition to <code>between</code>.
</dd>
<dt><code>divide</code></dt><dd>Number of point symbols to divide each line when <code>type</code> is
<code>"b"</code> or <code>"o"</code> in <code>lines</code>.
</dd>
</dl>
</dd>
<dt><code>legend</code>:</dt><dd>the legend argument can be useful if one wants to place more than
one key. It also allows one to use arbitrary <code>"grob"</code>s (grid
objects) as legends.
<br>
If used, <code>legend</code> must be a list, with an arbitrary number of
components. Each component must be named one of <code>"left"</code>,
<code>"right"</code>, <code>"top"</code>, <code>"bottom"</code> or <code>"inside"</code>.
The name <code>"inside"</code> can be repeated, but not the others.  This
name will be used to determine the location for that component, and
is similar to the <code>space</code> component of <code>key</code>.  If
<code>key</code> (or <code>colorkey</code> for <code><a href="levelplot.html">levelplot</a></code> and
<code><a href="cloud.html">wireframe</a></code>) is specified, their <code>space</code> component
must not conflict with the name of any component of <code>legend</code>.
<br>
Each component of <code>legend</code> must have a component called
<code>fun</code>. This can be a <code>"grob"</code>, or a function or the name of a
function that produces a <code>"grob"</code> when called. If this function
expects any arguments, they must be supplied as a list in another
component called <code>args</code>. For components named <code>"inside"</code>,
there can be additional components called <code>x</code>, <code>y</code> and
<code>corner</code>, which work in the same way as it does for <code>key</code>.
</dd>
<br>
<dt><code>page</code>:</dt><dd>a function of one argument (page number) to be called
after drawing each page. The function must be
&lsquo;grid-compliant&rsquo;, and is called with the whole display area
as the default viewport.
</dd>
<dt><code>main</code>:</dt><dd>typically a character string or expression
describing the main title to be placed on top of each page.
Defaults to <code>NULL</code>.  <code>main</code> (as well as <code>xlab</code>,
<code>ylab</code> and <code>sub</code>) is usually a character string or an
expression that gets used as the label, but can also be a list
that controls further details.  Expressions are treated as
specification of LaTeX-like markup as described in
<code><a href="../../grDevices/html/plotmath.html">plotmath</a></code>.  The label can be a vector, in which
case the components will be spaced out horizontally (or
vertically for <code>ylab</code>).  This feature can be used to
provide column or row labels rather than a single axis label.
<br>
When <code>main</code> (etc.) is a list, the actual label should be
specified as the <code>label</code> component (which may be unnamed if
it is the first component).  The label can be missing, in which
case the default will be used (<code>xlab</code> and <code>ylab</code>
usually have defaults, but <code>main</code> and <code>sub</code> do not).
Further named arguments are passed on to
<code><a href="../../grid/html/grid.text.html">textGrob</a></code>; this can include
arguments controlling positioning like <code>just</code> and
<code>rot</code> as well as graphical parameters such as <code>col</code>
and <code>font</code> (see <code><a href="../../grid/html/gpar.html">gpar</a></code> for a full
list).
<br>
<code>main</code>, <code>xlab</code>, <code>ylab</code> and <code>sub</code> can also be
an arbitrary <code>"grob"</code> (grid graphical object).
</dd>
<dt><code>sub</code>:</dt><dd>character string or expression (or a list or <code>"grob"</code>) for
a subtitle to be placed at the bottom of each page.  See entry
for <code>main</code> for finer control options.
</dd>
<dt><code>par.strip.text</code>:</dt><dd>list of  parameters to control the appearance
of strip text.  Notable components are <code>col</code>, <code>cex</code>,
<code>font</code> and <code>lines</code>.  The first three control graphical
parameters while the last is a means of altering the height of the
strips.  This can be useful, for example, if the strip labels
(derived from factor levels, say) are double height (i.e., contains
<code>"\n"</code>-s) or if the default height seems too small or too
large.  The <code>lineheight</code> component can control the space
between multiple lines.  Also, the labels can be abbreviated when
shown by specifying <code>abbreviate = TRUE</code>, in which case the
components <code>minlength</code> and <code>dot</code> (passed along to the
<code><a href="../../base/html/abbreviate.html">abbreviate</a></code> function) can be specified to control the
details of how this is done.
</dd>
<dt><code>layout</code>:</dt><dd>In general, a Trellis conditioning plot consists of several panels
arranged in a rectangular array, possibly spanning multiple
pages. <code>layout</code> determines this arrangement.
<br>
<code>layout</code> is a numeric vector giving the number of columns, rows
and pages in a multi panel display.  By default, the number of
columns is the number of levels of the first conditioning variable
and the number of rows is the number of levels of the second
conditioning variable.  If there is only one conditioning variable,
the default layout vector is <code>c(0,n)</code>, where <code>n</code> is the
number of levels of the given vector.  Any time the first value in
the layout vector is 0, the second value is used as the desired
number of panels per page and the actual layout is computed from
this, taking into account the aspect ratio of the panels and the
device dimensions (via <code>par("din")</code>).  The number of pages is
by default set to as many as is required to plot all the panels.  In
general, giving a high value of <code>layout[3]</code> is not wasteful
because blank pages are never created.
</dd>
<dt><code>skip</code>:</dt><dd>logical vector (default <code>FALSE</code>), replicated to be as long as
the number of panels (spanning all pages).  For elements that are
<code>TRUE</code>, the corresponding panel position is skipped; i.e.,
nothing is plotted in that position.  The panel that was supposed to
be drawn there is now drawn in the next available panel position,
and the positions of all the subsequent panels are bumped up
accordingly.  This is often useful for arranging plots in an
informative manner.
</dd>
<br>
<dt><code>strip.left</code>:</dt><dd><code>strip.left</code> can be used to draw strips on the left of each
panel, which can be useful for wide short panels, as in time
series (or similar) plots.  It is a function similar to
<code>strip</code>.
</dd>
<br>
<dt><code>xlab.default</code>, <code>ylab.default</code>:</dt><dd>fallback default
for <code>xlab</code> and <code>ylab</code> when they are not specified.  If
<code>NULL</code>, the defaults are parsed from the Trellis formula.
This is rarely useful for the end-user, but can be helpful when
developing new Trellis functions.</dd>
<br>
<dt><code>xscale.components, yscale.components</code>:</dt><dd>functions that determine axis annotation for the x and y axes
respectively.  See documentation for
<code><a href="axis.default.html">xscale.components.default</a></code>, the default values of
these arguments, to learn more. </dd>
<br>
<dt><code>axis</code>:</dt><dd>function that draws axis annotation.  See
documentation for <code><a href="axis.default.html">axis.default</a></code>, the default value
of this argument, to learn more. </dd>
<br>
<dt><code>perm.cond</code>:</dt><dd>numeric vector, a permutation of <code>1:n</code>, where <code>n</code> is the
number of conditioning variables.  By default, the order in which
panels are drawn depends on the order of the conditioning variables
specified in the <code>formula</code>.  <code>perm.cond</code> can modify this
order.  If the trellis display is thought of as an
<code>n</code>-dimensional array, then during printing, its dimensions are
permuted using <code>perm.cond</code> as the <code>perm</code> argument to
<code><a href="../../base/html/aperm.html">aperm</a></code>.
</dd>
<dt><code>index.cond</code>:</dt><dd>While <code>perm.cond</code> permutes the dimensions of the
multidimensional array of panels, <code>index.cond</code> can be used to
subset (or reorder) margins of that array.  <code>index.cond</code> can be
a list or a function, with behavior in each case described
below. 
<br>
The panel display order within each conditioning variable depends on
the order of their levels.  <code>index.cond</code> can be used to choose
a &lsquo;subset&rsquo; (in the R sense) of these levels, which is then
used as the display order for that variable.  If <code>index.cond</code>
is a list, it has to be as long as the number of conditioning
variables, and the <code>i</code>-th component has to be a valid
indexing vector for the integer vector <code>1:nlevels(g_i)</code>
(which can, among other things, repeat some of the levels or
drop some altogether).  The result of this indexing determines
the order of panels within that conditioning variable. To keep
the order of a particular variable unchanged, the corresponding
component must be set to <code>TRUE</code>.
<br>
Note that the components of <code>index.cond</code> are in the order of
the conditioning variables in the original call, and is not affected
by <code>perm.cond</code>.
<br>
Another possibility is to specify <code>index.cond</code> as a function.
In this case, this function is called once for each panel,
potentially with all arguments that are passed to the panel function
for that panel. (More specifically, if this function has a
<code>...</code> argument, then all panel arguments are passed,
otherwise, only named arguments that match are passed.) For a single
conditioning variable, the levels of that variable are then sorted
so that these values are in ascending order. For multiple
conditioning variables, the order for each variable is determined by
first taking the average over all other conditioning variables.
<br>
Although they can be supplied in high level function calls directly,
it is more typical to use <code>perm.cond</code> and <code>index.cond</code> to
update an existing <code>"trellis"</code> object, thus allowing it to be
displayed in a different arrangement without re-calculating the data
subsets that go into each panel. In the <code>update</code> method, both
can be set to <code>NULL</code>, which reverts these back to their
defaults.
</dd>
<dt><code>par.settings</code>:</dt><dd>a list that could be supplied to <code><a href="trellis.par.get.html">trellis.par.set</a></code>.
This enables the user to attach some display settings to the trellis
object itself rather than change the settings globally.  When the
object is plotted, these settings are temporarily in effect for
the duration of the plot, after which the settings revert back
to whatever they were before.
</dd>
<dt><code>plot.args</code>:</dt><dd>a list of possible arguments to <code><a href="print.trellis.html">plot.trellis</a></code>,
which will be used by the <code>plot</code> or <code>print</code> methods
when drawing the object, unless overridden explicitly.  This
enables the user to attach such arguments to the trellis object
itself.  Partial matching is not performed.
</dd>
</dl>
</td></tr>
</table>

<h3>Details</h3>

<p>
All the functions documented here are generic, with the <code>formula</code>
method usually doing the actual work.  The structure of the plot that
is produced is mostly controlled by the formula.  For each unique
combination of the levels of the conditioning variables <code>g1, g2,
    ...</code>, a separate panel is produced using the points <code>(x,y)</code>
for the subset of the data (also called packet) defined by that
combination.  The display can be though of as a 3-dimensional array of
panels, consisting of one 2-dimensional matrix per page.  The
dimensions of this array are determined by the <code>layout</code> argument.
If there are no conditioning variables, the plot produced consists of
a single panel.
</p>
<p>
The coordinate system used by lattice by default is like a graph,
with the origin at the bottom left, with axes increasing to left and
up. In particular, panels are by default drawn starting from the
bottom left corner, going right and then up; unless <code>as.table =
    TRUE</code>, in which case panels are drawn from the top left corner,
going right and then down.  One might wish to set a global preference
for a table-like arrangement by changing the default to
<code>as.table=TRUE</code>; this can be done by setting
<code>lattice.options(default.args = list(as.table = TRUE))</code>.  In
fact, default values can be set in this manner for the following
arguments: <code>as.table</code>, <code>aspect</code>, <code>between</code>,
<code>page</code>, <code>main</code>, <code>sub</code>, <code>par.strip.text</code>,
<code>layout</code>, <code>skip</code> and <code>strip</code>.  Note that these global
defaults are sometimes overridden by individual functions.
</p>
<p>
The order of the panels depends on the order in which the conditioning
variables are specified, with <code>g1</code> varying fastest. Within a
conditioning variable, the order depends on the order of the levels
(which for factors is usually in alphabetical order).  Both of these
orders can be modified using the <code>index.cond</code> and
<code>perm.cond</code> arguments, possibly using the
<code><a href="update.trellis.html">update</a></code> (and other related)
method(s).
</p>


<h3>Value</h3>

<p>
An object of class <code>"trellis"</code>. The
<code><a href="update.trellis.html">update</a></code> method can be used to
update components of the object and the
<code><a href="print.trellis.html">print</a></code> method (usually called by
default) will plot it on an appropriate plotting device.</p>

<h3>Note</h3>

<p>
Most of the arguments documented here are also applicable for the
other high level functions in the lattice package. These are not
described in any detail elsewhere unless relevant, and this should be
considered the canonical documentation for such arguments.
</p>
<p>
Any arguments passed to these functions and not recognized by them
will be passed to the panel function. Most predefined panel functions
have arguments that customize its output. These arguments are
described only in the help pages for these panel functions, but can
usually be supplied as arguments to the high level plot.
</p>


<h3>Author(s)</h3>

<p>
Deepayan Sarkar <a href="mailto:Deepayan.Sarkar@R-project.org">Deepayan.Sarkar@R-project.org</a>
</p>


<h3>References</h3>

<p>
Sarkar, Deepayan (2008) "Lattice: Multivariate Data Visualization with
R", Springer. <a href="http://lmdvr.r-forge.r-project.org/">http://lmdvr.r-forge.r-project.org/</a>
</p>


<h3>See Also</h3>

<p>
<code><a href="Lattice.html">Lattice</a></code> for an overview of the package, as well as 
<code><a href="barchart.table.html">barchart.table</a></code>,
<code><a href="Lattice.html">Lattice</a></code>,
<code><a href="print.trellis.html">print.trellis</a></code>,
<code><a href="shingles.html">shingle</a></code>,
<code><a href="banking.html">banking</a></code>,
<code><a href="../../stats/html/reshape.html">reshape</a></code>,
<code><a href="panel.xyplot.html">panel.xyplot</a></code>,
<code><a href="panel.bwplot.html">panel.bwplot</a></code>,
<code><a href="panel.barchart.html">panel.barchart</a></code>,
<code><a href="panel.dotplot.html">panel.dotplot</a></code>,
<code><a href="panel.stripplot.html">panel.stripplot</a></code>,
<code><a href="panel.superpose.html">panel.superpose</a></code>,
<code><a href="panel.functions.html">panel.loess</a></code>,
<code><a href="panel.functions.html">panel.linejoin</a></code>,
<code><a href="strip.default.html">strip.default</a></code>,
<code><a href="simpleKey.html">simpleKey</a></code>
<code><a href="trellis.par.get.html">trellis.par.set</a></code>
</p>


<h3>Examples</h3>

<pre>

## Not run: 
## wait for user input before each new page (like 'par(ask = TRUE)')
old.prompt &lt;- grid::grid.prompt(TRUE)
## End(Not run)

require(stats)

## Tonga Trench Earthquakes

Depth &lt;- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
update(trellis.last.object(),
       strip = strip.custom(strip.names = TRUE, strip.levels = TRUE),
       par.strip.text = list(cex = 0.75),
       aspect = "iso")

## Examples with data from `Visualizing Data' (Cleveland)
## (obtained from Bill Cleveland's Homepage :
## http://cm.bell-labs.com/cm/ms/departments/sia/wsc/, also
## available at statlib)

EE &lt;- equal.count(ethanol$E, number=9, overlap=1/4)
## Constructing panel functions on the fly; prepanel
xyplot(NOx ~ C | EE, data = ethanol,
       prepanel = function(x, y) prepanel.loess(x, y, span = 1),
       xlab = "Compression Ratio", ylab = "NOx (micrograms/J)",
       panel = function(x, y) {
           panel.grid(h=-1, v= 2)
           panel.xyplot(x, y)
           panel.loess(x,y, span=1)
       },
       aspect = "xy")


## with and without banking

plot &lt;- xyplot(sunspot.year ~ 1700:1988, xlab = "", type = "l",
               scales = list(x = list(alternating = 2)),
               main = "Yearly Sunspots")
print(plot, position = c(0, .3, 1, .9), more = TRUE)
print(update(plot, aspect = "xy", main = "", xlab = "Year"),
      position = c(0, 0, 1, .3))



## Multiple variables in formula for grouped displays

xyplot(Sepal.Length + Sepal.Width ~ Petal.Length + Petal.Width | Species, 
       data = iris, scales = "free", layout = c(2, 2),
       auto.key = list(x = .6, y = .7, corner = c(0, 0)))

## user defined panel functions

states &lt;- data.frame(state.x77,
                     state.name = dimnames(state.x77)[[1]], 
                     state.region = state.region) 
xyplot(Murder ~ Population | state.region, data = states, 
       groups = state.name, 
       panel = function(x, y, subscripts, groups)  
       ltext(x = x, y = y, labels = groups[subscripts], cex=1,
             fontfamily = "HersheySans"))

barchart(yield ~ variety | site, data = barley,
         groups = year, layout = c(1,6),
         ylab = "Barley Yield (bushels/acre)",
         scales = list(x = list(abbreviate = TRUE,
                       minlength = 5)))
barchart(yield ~ variety | site, data = barley,
         groups = year, layout = c(1,6), stack = TRUE, 
         auto.key = list(points = FALSE, rectangles = TRUE, space = "right"),
         ylab = "Barley Yield (bushels/acre)",
         scales = list(x = list(rot = 45)))

bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
dotplot(variety ~ yield | year * site, data=barley)

dotplot(variety ~ yield | site, data = barley, groups = year,
        key = simpleKey(levels(barley$year), space = "right"),
        xlab = "Barley Yield (bushels/acre) ",
        aspect=0.5, layout = c(1,6), ylab=NULL)

stripplot(voice.part ~ jitter(height), data = singer, aspect = 1,
          jitter.data = TRUE, xlab = "Height (inches)")
## Interaction Plot

xyplot(decrease ~ treatment, OrchardSprays, groups = rowpos,
       type = "a",
       auto.key =
       list(space = "right", points = FALSE, lines = TRUE))

## longer version with no x-ticks

## Not run: 
bwplot(decrease ~ treatment, OrchardSprays, groups = rowpos,
       panel = "panel.superpose",
       panel.groups = "panel.linejoin",
       xlab = "treatment",
       key = list(lines = Rows(trellis.par.get("superpose.line"),
                  c(1:7, 1)), 
                  text = list(lab = as.character(unique(OrchardSprays$rowpos))),
                  columns = 4, title = "Row position"))
## End(Not run)

## Not run: 
grid::grid.prompt(old.prompt)
## End(Not run)

</pre>



<hr><div align="center">[Package <em>lattice</em> version 0.17-25 <a href="00Index.html">Index</a>]</div>

</body></html>
