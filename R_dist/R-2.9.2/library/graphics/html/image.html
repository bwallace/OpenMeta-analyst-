<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Display a Color Image</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for image {graphics}"><tr><td>image {graphics}</td><td align="right">R Documentation</td></tr></table>
<h2>Display a Color Image</h2>


<h3>Description</h3>

<p>
Creates a grid of colored or gray-scale rectangles with colors
corresponding to the values in <code>z</code>.  This can be used to display
three-dimensional or spatial data aka <EM>images</EM>.
This is a generic function.
</p>
<p>
The functions <code><a href="../../grDevices/html/palettes.html">heat.colors</a></code>, <code><a href="../../grDevices/html/palettes.html">terrain.colors</a></code>
and <code><a href="../../grDevices/html/palettes.html">topo.colors</a></code> create heat-spectrum (red to white) and
topographical color schemes suitable for displaying ordered data, with
<code>n</code> giving the number of colors desired.
</p>


<h3>Usage</h3>

<pre>
image(x, ...)

## Default S3 method:
image(x, y, z, zlim, xlim, ylim, col = heat.colors(12),
      add = FALSE, xaxs = "i", yaxs = "i", xlab, ylab,
      breaks, oldstyle = FALSE, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>x,y</code></td>
<td>
locations of grid lines at which the values in <code>z</code> are
measured.  These must be finite, non-missing and in (strictly)
ascending order.  By default, equally
spaced values from 0 to 1 are used.  If <code>x</code> is a <code>list</code>,
its components <code>x$x</code> and <code>x$y</code> are used for <code>x</code>
and <code>y</code>, respectively. If the list has component <code>z</code> this
is used for <code>z</code>.</td></tr>
<tr valign="top"><td><code>z</code></td>
<td>
a matrix containing the values to be plotted (<code>NA</code>s are
allowed).  Note that <code>x</code> can be used instead of <code>z</code> for
convenience.</td></tr>
<tr valign="top"><td><code>zlim</code></td>
<td>
the minimum and maximum <code>z</code> values for which colors
should be plotted, defaulting to the range of the finite values of
<code>z</code>. Each of the given colors will be used to color an
equispaced interval of this range. The <EM>midpoints</EM> of the
intervals cover the range, so that values just outside the range
will be plotted.</td></tr>
<tr valign="top"><td><code>xlim, ylim</code></td>
<td>
ranges for the plotted <code>x</code> and <code>y</code> values,
defaulting to the ranges of <code>x</code> and <code>y</code>.</td></tr>
<tr valign="top"><td><code>col</code></td>
<td>
a list of colors such as that generated by
<code><a href="../../grDevices/html/palettes.html">rainbow</a></code>, <code><a href="../../grDevices/html/palettes.html">heat.colors</a></code>,
<code><a href="../../grDevices/html/palettes.html">topo.colors</a></code>, <code><a href="../../grDevices/html/palettes.html">terrain.colors</a></code> or similar
functions.</td></tr>
<tr valign="top"><td><code>add</code></td>
<td>
logical; if <code>TRUE</code>, add to current plot (and disregard
the following arguments).  This is rarely useful because
<code>image</code> &lsquo;paints&rsquo; over existing graphics.</td></tr>
<tr valign="top"><td><code>xaxs, yaxs</code></td>
<td>
style of x and y axis.  The default <code>"i"</code> is
appropriate for images.  See <code><a href="par.html">par</a></code>.</td></tr>
<tr valign="top"><td><code>xlab, ylab</code></td>
<td>
each a character string giving the labels for the x and
y axis.  Default to the &lsquo;call names&rsquo; of <code>x</code> or <code>y</code>, or to
<code>""</code> if these were unspecified.</td></tr>
<tr valign="top"><td><code>breaks</code></td>
<td>
a set of breakpoints for the colours: must give one more
breakpoint than colour.</td></tr>
<tr valign="top"><td><code>oldstyle</code></td>
<td>
logical. If true the midpoints of the colour intervals
are equally spaced, and <code>zlim[1]</code> and <code>zlim[2]</code> were taken
to be midpoints.  The default is to have colour intervals of equal
lengths between the limits.</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
graphical parameters for <code><a href="plot.html">plot</a></code> may also be
passed as arguments to this function, as can the plot aspect ratio
<code>asp</code> and <code>axes</code> (see <code><a href="plot.window.html">plot.window</a></code>).</td></tr>
</table>

<h3>Details</h3>

<p>
The length of <code>x</code> should be equal to the <code>nrow(z)+1</code> or
<code>nrow(z)</code>.  In the first case <code>x</code> specifies the boundaries
between the cells: in the second case <code>x</code> specifies the midpoints
of the cells.  Similar reasoning applies to <code>y</code>.  It probably
only makes sense to specify the midpoints of an equally-spaced
grid.  If you specify just one row or column and a length-one <code>x</code>
or <code>y</code>, the whole user area in the corresponding direction is
filled.
</p>
<p>
Rectangles corresponding to missing values are not plotted (and so are
transparent and (unless <code>add=TRUE</code>) the default background painted
in <code>par("bg")</code> will show though and if that is transparent, the
canvas colour will be seen).
</p>
<p>
If <code>breaks</code> is specified then <code>zlim</code> is unused and the
algorithm used follows <code><a href="../../base/html/cut.html">cut</a></code>, so intervals are closed on
the right and open on the left except for the lowest interval.
</p>
<p>
Notice that <code>image</code> interprets the <code>z</code> matrix as a table of
<code>f(x[i], y[j])</code> values, so that the x axis corresponds to row
number and the y axis to column number, with column 1 at the bottom,
i.e. a 90 degree counter-clockwise rotation of the conventional
printed layout of a matrix.
</p>


<h3>Note</h3>

<p>
Based on a function by Thomas Lumley
<a href="mailto:tlumley@u.washington.edu">tlumley@u.washington.edu</a>.
</p>


<h3>See Also</h3>

<p>
<code><a href="filled.contour.html">filled.contour</a></code> or <code><a href="../../stats/html/heatmap.html">heatmap</a></code> which can
look nicer (but are less modular),
<code><a href="contour.html">contour</a></code>;
The <span class="pkg">lattice</span> equivalent of <code>image</code> is
<code><a href="../../lattice/html/levelplot.html">levelplot</a></code>.
</p>
<p>
<code><a href="../../grDevices/html/palettes.html">heat.colors</a></code>, <code><a href="../../grDevices/html/palettes.html">topo.colors</a></code>,
<code><a href="../../grDevices/html/palettes.html">terrain.colors</a></code>, <code><a href="../../grDevices/html/palettes.html">rainbow</a></code>,
<code><a href="../../grDevices/html/hsv.html">hsv</a></code>, <code><a href="par.html">par</a></code>.
</p>


<h3>Examples</h3>

<pre>
require(grDevices) # for colours
x &lt;- y &lt;- seq(-4*pi, 4*pi, len=27)
r &lt;- sqrt(outer(x^2, y^2, "+"))
image(z = z &lt;- cos(r^2)*exp(-r/6), col=gray((0:32)/32))
image(z, axes = FALSE, main = "Math can be beautiful ...",
      xlab = expression(cos(r^2) * e^{-r/6}))
contour(z, add = TRUE, drawlabels = FALSE)

# Volcano data visualized as matrix. Need to transpose and flip
# matrix horizontally.
image(t(volcano)[ncol(volcano):1,])

# A prettier display of the volcano
x &lt;- 10*(1:nrow(volcano))
y &lt;- 10*(1:ncol(volcano))
image(x, y, volcano, col = terrain.colors(100), axes = FALSE)
contour(x, y, volcano, levels = seq(90, 200, by = 5),
        add = TRUE, col = "peru")
axis(1, at = seq(100, 800, by = 100))
axis(2, at = seq(100, 600, by = 100))
box()
title(main = "Maunga Whau Volcano", font.main = 4)
</pre>



<hr><div align="center">[Package <em>graphics</em> version 2.9.2 <a href="00Index.html">Index</a>]</div>

</body></html>
