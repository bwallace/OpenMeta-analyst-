<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>R: Community structure via greedy optimization of modularity</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link rel="stylesheet" type="text/css" href="../../R.css">
</head><body>

<table width="100%" summary="page for fastgreedy.community {igraph}"><tr><td>fastgreedy.community {igraph}</td><td align="right">R Documentation</td></tr></table>
<h2>Community structure via greedy optimization of modularity</h2>


<h3>Description</h3>

<p>
This function tries to find dense subgraph, also called communities in
graphs via directly optimizing a modularity score.
</p>


<h3>Usage</h3>

<pre>
fastgreedy.community(graph, merges=TRUE, modularity=TRUE,
      weights=E(graph)$weight)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>graph</code></td>
<td>
The input graph</td></tr>
<tr valign="top"><td><code>merges</code></td>
<td>
Logical scalar, whether to return the merge matrix.</td></tr>
<tr valign="top"><td><code>modularity</code></td>
<td>
Logcal scalar, whether to return a vector containing
the modularity after each merge.</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
If not <code>NULL</code>, then a numeric vector of edge
weights. The length must match the number of edges in the graph.
By default the &lsquo;<code>weight</code>&rsquo; edge attribute is used as
weights. If it is not present, then all edges are considered to have
the same weight.
</td></tr>
</table>

<h3>Details</h3>

<p>
This function implements the fast greedy modularity optimization
algorithm for finding community structure, see 
A Clauset, MEJ Newman, C Moore: Finding community structure in very
large networks, http://www.arxiv.org/abs/cond-mat/0408187 for the
details.
</p>


<h3>Value</h3>

<p>
A named list with the following members:
</p>
<table summary="R argblock">
<tr valign="top"><td><code>merges</code></td>
<td>
A matrix with two column, this represents a dendogram
and contains all the merges the algorithm performed. Each line is
one merge and it is given by the ids of the two communities
merged. The community ids are integer numbers starting from zero
and the communities between zero and the number of vertices
(<code>N</code>) minus one belong to individual vertices. The first line
of the matrix gives the first merge, this merge creates community
<code>N</code>, the number of vertices, the second merge creates
community <code>N+1</code>, etc.
</td></tr>
<tr valign="top"><td><code>modularity</code></td>
<td>
A numeric vector containing the modularity value 
of the community structure after performing every merge.
</td></tr>
</table>

<h3>Author(s)</h3>

<p>
Tamas Nepusz <a href="mailto:ntamas@rmki.kfki.hu">ntamas@rmki.kfki.hu</a> and Gabor Csardi
<a href="mailto:csardi@rmki.kfki.hu">csardi@rmki.kfki.hu</a> for the R interface.
</p>


<h3>References</h3>

<p>
A Clauset, MEJ Newman, C Moore: Finding community structure in very
large networks, http://www.arxiv.org/abs/cond-mat/0408187
</p>


<h3>See Also</h3>

<p>
<code><a href="walktrap.community.html">walktrap.community</a></code>,
<code><a href="spinglass.community.html">spinglass.community</a></code>,
<code><a href="leading.eigenvector.html">leading.eigenvector.community</a></code>,
<code><a href="community.edge.betweenness.html">edge.betweenness.community</a></code>
</p>


<h3>Examples</h3>

<pre>
g &lt;- graph.full(5) %du% graph.full(5) %du% graph.full(5)
g &lt;- add.edges(g, c(0,5, 0,10, 5, 10))
fastgreedy.community(g)
# The highest value of modularity is before performing the last two
# merges. So this network naturally has three communities.
</pre>



<hr><div align="center">[Package <em>igraph</em> version 0.5.2-2 <a href="00Index.html">Index</a>]</div>

</body></html>
